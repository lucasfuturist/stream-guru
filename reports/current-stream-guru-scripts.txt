
ðŸ“ Tree for: C:\projects\stream-guru\scripts
----------------------------------------
scripts
+-- utils
|   L-- genre-map.ts
+-- embed_all.ts
+-- ping-supa.cjs
+-- ping.ts
L-- tmdb_seed.ts

ðŸ“œ Listing scripts with extensions: .ts, .txt, .tsx, .js, .jsx, .py, .html, .json, .css, .sql, .toml, .cjs, .ps1
----------------------------------------

### embed_all.ts

// scripts/embed_all.ts

import "dotenv/config";
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";

// --- CONFIGURATION ---
const BATCH_SIZE = 50;
const MAX_RETRIES = 5;
const INITIAL_RETRY_DELAY_MS = 2000;

// --- CLIENTS ---
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE!
);
const openai = new OpenAI({ apiKey: process.env.OPENAI_KEY! });

// --- HELPER ---
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function main() {
  if (!process.env.OPENAI_KEY) throw new Error("OPENAI_KEY missing");

  while (true) {
    const { data: rows, error } = await supabase
      .from("media")
      .select("id, title, synopsis, genres")
      .is("embedding", null)
      .limit(BATCH_SIZE);

    if (error) throw error;
    if (!rows.length) {
      console.log("âœ… All rows embedded.");
      return;
    }

    const inputs = rows.map(
      (r) => `${r.title}. ${r.synopsis}. genres: ${r.genres.join(", ")}`
    );

    let resp;
    // Step 1: Fetch embeddings from OpenAI (with retry)
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`Attempting to embed ${rows.length} rows (Attempt ${attempt}/${MAX_RETRIES})...`);
        resp = await openai.embeddings.create({
          model: "text-embedding-3-small", input: inputs, encoding_format: "float"
        });
        console.log("âœ… OpenAI API call successful.");
        break; 
      } catch (err) {
        if (attempt === MAX_RETRIES) throw err;
        const delayTime = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt - 1);
        console.warn(`âš ï¸ OpenAI API call failed. Retrying in ${delayTime / 1000}s...`);
        await delay(delayTime);
      }
    }
    if (!resp) throw new Error("Failed to get response from OpenAI after all retries.");
    
    // Step 2: Prepare the payload for our new RPC function
    const updates = rows.map((row, i) => ({
      id_to_update: row.id,
      embedding_vector: `[${resp.data[i].embedding.join(",")}]`
    }));

    // Step 3: Call the RPC function to update the entire batch at once (with retry)
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            console.log(`Attempting to save ${updates.length} embeddings via RPC (Attempt ${attempt}/${MAX_RETRIES})...`);
            // This single line replaces the entire upsert loop
            const { error: rpcError } = await supabase.rpc('update_media_embeddings', { updates });
            
            if (rpcError) throw rpcError;

            console.log(`âœ… Successfully embedded and saved ${rows.length} rows.`);
            break; 
        } catch (err) {
            if (attempt === MAX_RETRIES) {
                console.error("âŒ All RPC attempts failed.");
                throw err;
            }
            const delayTime = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt - 1);
            console.warn(`âš ï¸ RPC call failed. Retrying in ${delayTime / 1000}s...`, err.message);
            await delay(delayTime);
        }
    }
  }
}

main().catch((err) => {
  console.error("âŒ embed_all script failed:", err.message);
  process.exit(1);
});

### ping-supa.cjs

const { createClient } = require("@supabase/supabase-js");

const supa = createClient(
  process.env.SB_URL,
  process.env.SB_SERVICE_ROLE_KEY
);

(async () => {
  const { data, error } = await supa.from("media").select("*").limit(1);
  if (error) throw error;
  console.log("âœ… pulled row:", data);
})();

### ping.ts

// ping.ts
import { createClient } from "@supabase/supabase-js";
import "dotenv/config"; // This will load your .env file

// Use the variable names from your .env file
const supaUrl = process.env.SUPABASE_URL!;
const supaServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

const supa = createClient(supaUrl, supaServiceKey);

const run = async () => {
  console.log("Pinging Supabase to test credentials...");
  const { data, error } = await supa.from("media").select("id, title").limit(1);

  if (error) {
    console.error("âŒ Supabase query failed. Check your URL and Service Role Key.");
    console.error(error);
    throw error;
  }

  console.log("âœ… Successfully pulled a row:", data);
};

run();

### tmdb_seed.ts

// scripts/tmdb_seed.ts

import "dotenv/config";
import { createClient } from "@supabase/supabase-js";

// --- ROBUST Argument Parsing ---
let mode: 'totalItems' | 'singlePage' = 'totalItems';
let targetValue: number;

const pageArgIndex = process.argv.indexOf('--page');

if (pageArgIndex > -1) {
  // Check if a value exists after the --page flag
  if (process.argv[pageArgIndex + 1]) {
    mode = 'singlePage';
    targetValue = parseInt(process.argv[pageArgIndex + 1], 10);
  } else {
    throw new Error("The --page flag requires a number after it.");
  }
} else {
  // In production mode, the argument is the 3rd element (node, script, arg)
  const totalItemsArg = process.argv[2];
  targetValue = totalItemsArg ? parseInt(totalItemsArg, 10) : 2000;
}

if (isNaN(targetValue)) {
    throw new Error(`Invalid argument provided. Expected a number, but got NaN.`);
}
// --- End Argument Parsing ---


// --- CONFIGURATION ---
const ITEMS_PER_PAGE = 40;
const TOTAL_PAGES_TO_FETCH = mode === 'totalItems' ? Math.ceil(targetValue / ITEMS_PER_PAGE) : 1;
// ... (The rest of the file is unchanged)

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE!);
const V4 = process.env.TMDB_V4_API_KEY?.trim();
const V3 = process.env.TMDB_V3_API_KEY?.trim();
if (!V4 && !V3) throw new Error("TMDB API key not found");
const TMDB_API = "https://api.themoviedb.org/3";
const headers = V4 ? { Authorization: `Bearer ${V4}` } : {};
const MAX_RETRIES = 3;
const INITIAL_RETRY_DELAY = 2000;

const url = (path: string, params?: Record<string, string>) => {
    const url = new URL(`${TMDB_API}${path}`);
    if (V3) url.searchParams.set("api_key", V3);
    if (params) Object.entries(params).forEach(([key, value]) => url.searchParams.set(key, value));
    return url.toString();
};
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
async function fetchWithRetry(url: string, options: RequestInit, retries = MAX_RETRIES): Promise<any> {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response.json();
      if (response.status >= 400 && response.status < 500) {
        console.warn(`Client error fetching ${url}: ${response.status}. Not retrying.`);
        return null;
      }
      throw new Error(`Server error: ${response.status}`);
    } catch (error) {
      if (i === retries - 1) {
        console.error(`Final attempt failed for ${url}. Error:`, error.message);
        return null;
      }
      const delayMs = INITIAL_RETRY_DELAY * Math.pow(2, i);
      console.warn(`Request failed for ${url}. Retrying in ${delayMs / 1000}s... (Attempt ${i + 1}/${retries})`);
      await delay(delayMs);
    }
  }
  return null;
}
async function getBaseConfig() {
  return fetchWithRetry(url("/configuration"), { headers });
}
async function fetchDetails(kind: "movie" | "tv", id: number) {
  return fetchWithRetry(url(`/${kind}/${id}`, { append_to_response: "videos,credits,images" }), { headers });
}
async function processPage(page: number, config: any) {
  console.log(`--- Processing Page ${page} ---`);
  const [moviesData, tvData] = await Promise.all([
    fetchWithRetry(url("/movie/popular", { page: String(page) }), { headers }),
    fetchWithRetry(url("/tv/popular", { page: String(page) }), { headers })
  ]);
  if (!moviesData?.results || !tvData?.results) {
    console.warn(`Could not fetch list for page ${page}. Skipping.`);
    return 0;
  }
  const itemsToFetch = [
    ...moviesData.results.map((m: any) => ({ id: m.id, media_type: "movie" as const })),
    ...tvData.results.map((t: any) => ({ id: t.id, media_type: "tv" as const })),
  ];
  if (itemsToFetch.length === 0) return -1;
  console.log(`Found ${itemsToFetch.length} items. Fetching details...`);
  const detailedItems = [];
  for (const item of itemsToFetch) {
    const details = await fetchDetails(item.media_type, item.id);
    if (details) detailedItems.push(details);
    await delay(50);
  }
  const rows = detailedItems.filter(Boolean).filter((d: any) => d.overview && d.poster_path && d.genres?.length > 0)
    .map((d: any) => {
        const officialTrailer = d.videos?.results?.find((v: any) => v.site === "YouTube" && v.type === "Trailer" && v.official);
        const director = d.credits?.crew?.find((c: any) => c.job === "Director");
        const englishLogo = d.images?.logos?.find((l: any) => l.iso_639_1 === "en");
        const anyLogo = d.images?.logos?.[0];
        const logo = englishLogo || anyLogo;
        const topCast = d.credits?.cast?.slice(0, 6).map((actor: any) => ({ name: actor.name, character: actor.character, profile_path: actor.profile_path ? `${config.secure_base_url}${config.profile_size}${actor.profile_path}` : null }));
        return {
            tmdb_id: d.id, media_type: d.title ? "movie" : "tv", title: d.title ?? d.name!, synopsis: d.overview, genres: d.genres.map((g: any) => g.name).filter(Boolean),
            poster_path: `${config.secure_base_url}${config.poster_size}${d.poster_path}`, release_date: d.release_date ?? d.first_air_date ?? null, popularity: d.popularity,
            runtime: d.runtime ?? d.episode_run_time?.[0] ?? null, tagline: d.tagline || null, director: director?.name || null, trailer_key: officialTrailer?.key || null,
            backdrop_path: d.backdrop_path ? `${config.secure_base_url}${config.backdrop_size}${d.backdrop_path}` : null,
            logo_path: logo ? `${config.secure_base_url}${config.logo_size}${logo.file_path}` : null, top_cast: topCast || null,
        };
    });
  if (rows.length > 0) {
    const { error } = await supabase.from("media").upsert(rows, { onConflict: "tmdb_id" });
    if (error) { console.error("Supabase upsert error:", error.message); return 0; }
    console.log(`Upserted ${rows.length} valid rows.`);
    return rows.length;
  }
  return 0;
}
(async () => {
    console.log("ðŸš€ Seeder script initializing...");
    const config = await getBaseConfig();
    if (!config) { console.error("Could not fetch TMDb configuration. Aborting."); return; }
    let totalSeeded = 0;
    if (mode === 'singlePage') {
        console.log(`Running in SINGLE PAGE mode for page ${targetValue}.`);
        await processPage(targetValue, config);
    } else {
        console.log(`Running in TOTAL ITEMS mode. Goal: ~${targetValue} items across ${TOTAL_PAGES_TO_FETCH} pages.`);
        for (let page = 1; page <= TOTAL_PAGES_TO_FETCH; page++) {
            const seededCount = await processPage(page, config);
            if (seededCount === -1) { console.log("No more items found on TMDb, ending process early."); break; }
            totalSeeded += seededCount;
            console.log(`âœ… Page ${page} complete. Total items seeded so far: ${totalSeeded}`);
        }
    }
    console.log(`\nðŸŽ‰ Seeder script finished!`);
})();

### genre-map.ts

/**
 * TMDb genre ID â†’ human-readable label.
 * Includes the union of movie + TV genre IDs.
 */
export const genreMap: Record<number, string> = {
  // shared / movie genres
  28: "Action",
  12: "Adventure",
  16: "Animation",
  35: "Comedy",
  80: "Crime",
  99: "Documentary",
  18: "Drama",
  10751: "Family",
  14: "Fantasy",
  36: "History",
  27: "Horror",
  10402: "Music",
  9648: "Mystery",
  10749: "Romance",
  878: "Science Fiction",
  10770: "TV Movie",
  53: "Thriller",
  10752: "War",
  37: "Western",

  // tv-only adds
  10759: "Action & Adventure",
  10762: "Kids",
  10763: "News",
  10764: "Reality",
  10765: "Sci-Fi & Fantasy",
  10766: "Soap",
  10767: "Talk",
  10768: "War & Politics"
};

----------------------------------------
----------------------------------------